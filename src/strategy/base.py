import abc
import logging
from typing import Dict, List, Tuple

import pandas as pd

class Strategy(abc.ABC):
    """
    Abstract base class for all trading strategies.

    Attributes:
        logger: Logger instance for logging strategy events.
    """

    def __init__(self, logger: logging.Logger):
        """
        Initializes the strategy with a logger.

        Args:
            logger: Logger instance for logging strategy events.
        """
        self.logger = logger

    @abc.abstractmethod
    def generate_signals(self, historical_data: Dict[str, pd.DataFrame]) -> Dict[str, str]:
        """
        Generates trading signals based on historical data.

        Args:
            historical_data: A dictionary of pandas DataFrames containing historical data for each asset.
                           The keys are the asset symbols (e.g., "BTCUSD"), and the values are DataFrames
                           with columns like 'open', 'high', 'low', 'close', 'volume'.

        Returns:
            A dictionary of trading signals for each asset.
            The keys are the asset symbols (e.g., "BTCUSD"), and the values are strings representing the signal:
            - "buy":  Indicates a buy signal.
            - "sell": Indicates a sell signal.
            - "hold": Indicates no signal.
        """
        raise NotImplementedError

    def backtest(self, historical_data: Dict[str, pd.DataFrame], initial_capital: float) -> pd.DataFrame:
        """
        Backtests the strategy on historical data.

        Args:
            historical_data: A dictionary of pandas DataFrames containing historical data for each asset.
                           The keys are the asset symbols (e.g., "BTCUSD"), and the values are DataFrames
                           with columns like 'open', 'high', 'low', 'close', 'volume'.
            initial_capital: The initial capital to use for backtesting.

        Returns:
            A pandas DataFrame containing the backtesting results.
            The DataFrame should include columns for:
            - 'timestamp': The timestamp of the data.
            - 'asset': The asset symbol.
            - 'signal': The trading signal generated by the strategy.
            - 'price': The price of the asset at the time of the signal.
            - 'position': The position held in the asset (e.g., number of units).
            - 'pnl': The profit and loss for each trade.
            - 'cumulative_pnl': The cumulative profit and loss over time.
        """
        self.logger.info("Starting backtest...")
        results = []
        portfolio_value = initial_capital
        positions: Dict[str, float] = {}  # Track positions for each asset
        cumulative_pnl = 0.0

        # Ensure all dataframes have the same index type (datetime)
        for asset, df in historical_data.items():
            if not isinstance(df.index, pd.DatetimeIndex):
                try:
                    historical_data[asset] = df.set_index(pd.to_datetime(df.index))
                except Exception as e:
                    self.logger.error(f"Error converting index to datetime for {asset}: {e}")
                    raise

        # Find the common time index across all assets
        common_index = None
        for asset, df in historical_data.items():
            if common_index is None:
                common_index = df.index
            else:
                common_index = common_index.intersection(df.index)

        if common_index is None or len(common_index) == 0:
            self.logger.warning("No common time index found across all assets. Backtest will return empty results.")
            return pd.DataFrame()

        # Align all dataframes to the common index
        for asset, df in historical_data.items():
            historical_data[asset] = df.reindex(common_index)

        # Iterate through the common time index
        for timestamp in common_index:
            # Prepare a slice of historical data for the current timestamp
            current_data = {}
            for asset, df in historical_data.items():
                current_data[asset] = df.loc[[timestamp]]  # Keep it as a DataFrame

            # Generate signals for the current timestamp
            signals = self.generate_signals(current_data)

            # Execute trades based on the signals
            for asset, signal in signals.items():
                price = historical_data[asset]['close'].loc[timestamp]

                if asset not in positions:
                    positions[asset] = 0.0

                if signal == "buy":
                    # Buy logic (simplified: buy as much as possible with available capital)
                    amount_to_buy = portfolio_value / price
                    positions[asset] += amount_to_buy
                    portfolio_value -= amount_to_buy * price # Deduct cost of purchase
                    self.logger.debug(f"BUY {asset} at {price}. Position: {positions[asset]}, Portfolio Value: {portfolio_value}")

                    pnl = 0.0  # Initial P&L for the trade
                    results.append({
                        'timestamp': timestamp,
                        'asset': asset,
                        'signal': signal,
                        'price': price,
                        'position': positions[asset],
                        'pnl': pnl,
                        'cumulative_pnl': cumulative_pnl
                    })

                elif signal == "sell":
                    # Sell logic (sell all current position)
                    pnl = (price - historical_data[asset]['close'].iloc[0]) * positions[asset] # P&L from selling
                    portfolio_value += positions[asset] * price # Add proceeds from sale
                    cumulative_pnl += pnl
                    self.logger.debug(f"SELL {asset} at {price}. Position: {positions[asset]}, P&L: {pnl}, Cumulative P&L: {cumulative_pnl}, Portfolio Value: {portfolio_value}")
                    results.append({
                        'timestamp': timestamp,
                        'asset': asset,
                        'signal': signal,
                        'price': price,
                        'position': 0.0,
                        'pnl': pnl,
                        'cumulative_pnl': cumulative_pnl
                    })
                    positions[asset] = 0.0  # Clear position after selling

        # Convert results to DataFrame
        results_df = pd.DataFrame(results)
        if not results_df.empty:
            results_df = results_df.set_index('timestamp')
        self.logger.info("Backtest complete.")
        return results_df